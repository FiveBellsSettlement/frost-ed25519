package rounds

import (
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/taurusgroup/frost-ed25519/pkg/messages"
)

type RoundState uint8

const (
	ProcessMessages RoundState = 1 << iota
	ProcessRound
	GenerateMessages
	NextRound

	Finished
	Abort
)

// BaseRound can be seen as the basic state that both protocols should have.
// It provides functionality for handling party IDs, a wrapper for the message queue,
// as well handling the current execution state.
type BaseRound struct {
	// AllPartyIDs is a sorted list of uint32 which represent all parties (including this one)
	// that are participating in the Round
	AllPartyIDs []uint32

	// OtherPartyIDs is a set of IDs from all other parties. It is not ordered, and is mostly used to
	// iterate over the list of IDs.
	OtherPartyIDs map[uint32]bool

	messages *Queue

	errorChan chan error
	state     RoundState

	isProcessingStep bool

	timeout time.Duration
	timer   *time.Timer

	selfPartyID uint32
	roundNumber int

	mtx sync.Mutex
}

func NewBaseRound(selfPartyID uint32, allPartyIDs []uint32, acceptedTypes []messages.MessageType, timeout time.Duration) (*BaseRound, error) {
	var baseRound BaseRound
	if selfPartyID == 0 {
		return nil, errors.New("selfPartyID cannot be 0")
	}
	baseRound.selfPartyID = selfPartyID

	foundSelfIDInAll := false
	finalAllPartyIDs := make([]uint32, 0, len(allPartyIDs))
	otherPartyIDs := make(map[uint32]bool, len(allPartyIDs))
	for _, id := range allPartyIDs {
		if id == 0 {
			return nil, errors.New("IDs in allPartyIDs cannot be 0")
		}
		if id == selfPartyID && !foundSelfIDInAll {
			finalAllPartyIDs = append(finalAllPartyIDs, id)
			foundSelfIDInAll = true
			continue
		}
		if _, ok := otherPartyIDs[id]; !ok {
			otherPartyIDs[id] = true
			finalAllPartyIDs = append(finalAllPartyIDs, id)
		}
	}
	baseRound.OtherPartyIDs = otherPartyIDs

	if !foundSelfIDInAll {
		return nil, errors.New("selfPartyID must be included in allPartyIDs")
	}
	baseRound.AllPartyIDs = finalAllPartyIDs

	var err error
	baseRound.messages, err = NewMessageQueue(acceptedTypes, len(allPartyIDs))
	if err != nil {
		return nil, err
	}

	baseRound.errorChan = make(chan error, 1)

	// The first Round will not have ProcessMessages function, so we give the sentinel to ProcessRound
	baseRound.state = ProcessRound

	baseRound.timeout = timeout
	if timeout > 0 {
		f := func() { baseRound.Abort(0, errors.New("message timeout")) }
		baseRound.timer = time.AfterFunc(timeout, f)
	}

	return &baseRound, nil
}

// PrepareNextRound checks whether the state of the Round allows us to continue on to the next one.
// If so, then we update the Round number and state, and the caller can then return the next Round.
func (b *BaseRound) PrepareNextRound() bool {
	b.mtx.Lock()
	defer b.mtx.Unlock()
	if b.state == NextRound {
		b.state = ProcessMessages
		b.roundNumber++
		return true
	}
	return false
}

func (b *BaseRound) terminate() {
	b.mtx.Lock()
	defer b.mtx.Unlock()

	if b.timer != nil {
		b.timer.Stop()
	}
}

// Abort should be called whenever something bad has happened, where we suspect malicious behaviour.
func (b *BaseRound) Abort(culprit uint32, err error) {
	b.mtx.Lock()
	defer b.mtx.Unlock()
	if b.state == Abort || b.state == Finished {
		return
	}
	b.state = Abort

	b.errorChan <- fmt.Errorf("abort: party %d: %w", culprit, err)
	close(b.errorChan)
}

// Finish should be called by a defer statement by the last Round of the protocol.
// If an abort happens, then we don't update.
func (b *BaseRound) Finish() {
	b.mtx.Lock()
	defer b.mtx.Unlock()
	if b.state == Abort || b.state == Finished {
		return
	}
	b.state = Finished
	defer close(b.errorChan)
}

func (b *BaseRound) Error() chan error {
	return b.errorChan
}

// -----
// Round life cycle
//
// These methods should be called at the beginning of the appropriate Round function,
// accompanied by a defer to NextStep
// -----

func (b *BaseRound) CanProcessMessages() bool {
	b.mtx.Lock()
	defer b.mtx.Unlock()

	if b.isProcessingStep {
		return false
	}

	if b.state == ProcessMessages && b.messages.ReceivedAll() {
		b.isProcessingStep = true
		return true
	}

	return false
}

func (b *BaseRound) CanProcessRound() bool {
	b.mtx.Lock()
	defer b.mtx.Unlock()

	if b.isProcessingStep {
		return false
	}

	if b.state == ProcessRound {
		b.isProcessingStep = true
		return true
	}

	return false
}

func (b *BaseRound) CanGenerateMessages() bool {
	b.mtx.Lock()
	defer b.mtx.Unlock()

	if b.isProcessingStep {
		return false
	}

	if b.state == GenerateMessages {
		b.isProcessingStep = true
		return true
	}

	return false
}

// NextStep advances the state, but only if the current state was one of the three above functions
func (b *BaseRound) NextStep() {
	b.mtx.Lock()
	defer b.mtx.Unlock()
	switch b.state {
	case ProcessMessages:
		b.isProcessingStep = false
		b.state <<= 1
		b.messages.NextRound()
	case ProcessRound, GenerateMessages:
		b.isProcessingStep = false
		b.state <<= 1
	}
}

// ----
// Getters
// ----

// ID is the uint32 ID of the party executing this Round.
func (b *BaseRound) ID() uint32 {
	return b.selfPartyID
}

// RoundNumber returns the current Round number
func (b *BaseRound) RoundNumber() int {
	return b.roundNumber
}

// N returns the number of parties participating.
func (b *BaseRound) N() int {
	return len(b.AllPartyIDs)
}

// ----
// Misc
// ----

// ProcessMessages is implemented here as an empty function so that the BaseRound and subsequent initial Round
// satisfies the Round interface, even when there are no messages to process.
func (b *BaseRound) ProcessMessages() {
}

// -----
// Queue
// -----

// StoreMessage takes in an unmarshalled wire message and attempts to store it in the messages.Queue.
// It returns an error depending on whether the messages.Queue was able to store it.
func (b *BaseRound) StoreMessage(message *messages.Message) error {
	if b.timer != nil {
		b.timer.Reset(b.timeout)
	}

	// Ignore messages from self
	if message.From == b.selfPartyID {
		return nil
	}
	// Ignore message not addressed to us
	if message.To != 0 && message.To != b.selfPartyID {
		return nil
	}
	// Is the sender in our list of participants?
	if !b.OtherPartyIDs[message.From] {
		return errors.New("sender is not a party")
	}

	return b.messages.Store(message)
}

// Messages fetches the message from the queue for the current Round.
func (b *BaseRound) Messages() map[uint32]*messages.Message {
	return b.messages.Messages()
}
